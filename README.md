# NOTE

This project is still under active development and isn't working correctly.

# CharmVZ

A high-performance alternative to the Projections visualization tool for analyzing Charm++ trace files. Instead of providing a GUI interface, CharmVZ converts trace data into Parquet files that can be easily analyzed using R, Python, Julia, and other data science tools.

## Overview

CharmVZ (Charm Visualization) is designed to bridge the gap between Charm++ performance tracing and modern data analysis workflows. While [Projections](https://github.com/charmplusplus/projections) provides an excellent GUI for interactive visualization, CharmVZ focuses on enabling programmatic analysis and custom visualizations by converting trace data into structured, queryable formats.

### Key Features

- **Fast trace processing**: C++20 implementation optimized for large trace files
- **Parquet output**: Industry-standard columnar format for efficient analytics
- **Complete timeline reconstruction**: Implements the same state machine as Projections
- **Multi-language support**: Generated data can be analyzed in R, Python, Julia, etc.
- **Batch processing**: Designed for automated analysis pipelines
- **Configurable filtering**: Time range and duration-based event filtering

## Installation

### Prerequisites

- C++20 compatible compiler (GCC 10+, Clang 12+, or MSVC 2019+)
- [Meson](https://mesonbuild.com/) build system
- [Ninja](https://ninja-build.org/) build backend

### Dependencies

CharmVZ automatically manages the following dependencies through Meson:

- **spdlog** (≥1.15.3): Logging framework
- **CLI11** (≥2.5.0): Command-line argument parsing  
- **zlib**: Compression support for .gz log files
- **zstr**: C++ wrapper for compressed stream I/O
- **Catch2** (≥3.10.0): Testing framework (development only)

### Build Instructions

```bash
# Clone the repository
git clone https://github.com/caschb/charmvz-cpp.git
cd charmvz-cpp

# Configure the build
meson setup build

# Compile
meson compile -C build

# Run tests (optional)
meson test -C build
```

## Usage

### Basic Timeline Analysis

```bash
# Process a single trace file
./build/charmvz trace_file.sts log_directory/

# Process with time range filtering
./build/charmvz trace_file.sts log_directory/ --start-time 1000 --end-time 5000

# Filter short events (minimum duration in microseconds)
./build/charmvz trace_file.sts log_directory/ --min-duration 100
```

### Input Files

CharmVZ processes standard Charm++ trace files:

- **STS file** (`*.sts`): Summary trace specification containing metadata
- **Log files** (`*.prj.N.log.gz`): Compressed per-processor trace logs

These files are generated by running Charm++ applications with tracing enabled:

```bash
# Enable tracing in your Charm++ application
./charmrun +p4 ./myapp ++trace-dir traces/
```

### Output Format

CharmVZ generates structured data files suitable for analysis:

- **Timeline events**: Begin/end times, entry points, processor information
- **Message data**: Send/receive times, message sizes, communication patterns  
- **Performance metrics**: Execution times, idle periods, packing overhead
- **Metadata**: Log IDs, processor mappings, trace statistics

## Programming Interface

### C++ API

```cpp
#include "timeline.h"

// Basic timeline creation
Timeline timeline = create_timeline("app.prj.0.log.gz");

// Advanced filtering
Timeline filtered = create_timeline("app.prj.0.log.gz", 
                                   start_time, end_time, min_duration);

// Access timeline events
for (const auto& event : timeline.events) {
    std::cout << "Entry " << event.entry_point 
              << " ran for " << (event.end_time - event.begin_time) 
              << " microseconds\n";
}
```

### Data Analysis Examples

Once you have the generated data files, you can analyze them using your preferred tools:

#### Python with Pandas

```python
import pandas as pd

# Load timeline data
df = pd.read_parquet('timeline_events.parquet')

# Analyze execution times by entry point
execution_times = df.groupby('entry_point')['duration'].agg(['mean', 'std', 'count'])

# Visualize communication patterns
import matplotlib.pyplot as plt
df['duration'].hist(bins=50)
plt.xlabel('Event Duration (μs)')
plt.ylabel('Frequency')
plt.show()
```

#### R with dplyr

```r
library(dplyr)
library(ggplot2)

# Load and analyze timeline data
timeline <- read_parquet("timeline_events.parquet")

# Summarize by processor
proc_summary <- timeline %>%
  group_by(processor) %>%
  summarise(
    total_time = sum(duration),
    event_count = n(),
    avg_duration = mean(duration)
  )

# Create visualizations
ggplot(timeline, aes(x = begin_time, y = processor, color = entry_point)) +
  geom_segment(aes(xend = end_time, yend = processor)) +
  theme_minimal() +
  labs(title = "Timeline Visualization")
```

## Architecture

CharmVZ implements the same core algorithms as Projections but optimized for batch processing:

### Performance Optimizations

- **Streaming processing**: Events are processed as they're read from disk
- **Memory efficient**: Only active timeline events are kept in memory
- **Compressed I/O**: Direct reading of .gz files without decompression
- **Minimal copying**: Move semantics used throughout for large data structures

## Contributing

Contributions are welcome!

### Development Setup

```bash
# Install development dependencies
meson setup build --buildtype=debug

# Run tests with coverage
meson test -C build

# Format code
clang-format -i src/**/*.cpp src/**/*.h
```

## License

See [LICENSE](LICENSE) for details.

## Acknowledgments

- **Projections Team**: For the original algorithms and trace format specifications
- **Charm++ Team**: For the runtime tracing infrastructure

## Related Projects

- [Projections](https://github.com/charmplusplus/projections): Interactive GUI-based visualization tool
- [Charm++](https://github.com/UIUC-PPL/charm): Parallel programming framework
- [TraceR](https://github.com/LLNL/TraceR): Trace replay framework for HPC applications

## Support

- **Issues**: Report bugs and feature requests via [GitHub Issues](https://github.com/caschb/charmvz-cpp/issues)